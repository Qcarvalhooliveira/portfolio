{"version":3,"file":"generateUniformsSyncPolyfill.mjs","sources":["../../../src/unsafe-eval/uniforms/generateUniformsSyncPolyfill.ts"],"sourcesContent":["import { uniformParsers } from '../../rendering/renderers/shared/shader/utils/uniformParsers';\nimport { uniformArrayParserFunctions, uniformParserFunctions, uniformSingleParserFunctions } from './uniformSyncFunctions';\n\nimport type { GlUniformData } from '../../rendering/renderers/gl/shader/GlProgram';\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { UniformsSyncCallback } from '../../rendering/renderers/shared/shader/types';\nimport type { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport type { UniformUploadFunction } from './uniformSyncFunctions';\n\nexport function generateUniformsSyncPolyfill(\n    group: UniformGroup,\n    uniformData: Record<string, GlUniformData>\n): UniformsSyncCallback\n{\n    // loop through all the uniforms..\n    const functionMap: Record<string, UniformUploadFunction> = {};\n\n    for (const i in group.uniformStructures)\n    {\n        if (!uniformData[i]) continue;\n\n        const uniform = group.uniformStructures[i];\n\n        let parsed = false;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const parser = uniformParsers[j];\n\n            if (uniform.type === parser.type && parser.test(uniform))\n            {\n                functionMap[i] = uniformParserFunctions[j];\n\n                parsed = true;\n\n                break;\n            }\n        }\n\n        // if not parsed...\n\n        if (!parsed)\n        {\n            const templateType = uniform.size === 1 ? uniformSingleParserFunctions : uniformArrayParserFunctions;\n\n            functionMap[i] = templateType[uniform.type];\n        }\n    }\n\n    return (\n        ud: Record<string, any>,\n        uv: Record<string, any>,\n        renderer: WebGLRenderer) =>\n    {\n        const gl = renderer.gl;\n\n        for (const i in functionMap)\n        {\n            const v = uv[i];\n            const cu = ud[i];\n            const cv = ud[i].value;\n\n            functionMap[i](i, cu, cv, v, ud, uv, gl);\n        }\n    };\n}\n"],"names":[],"mappings":";;;;AASgB,SAAA,4BAAA,CACZ,OACA,WAEJ,EAAA;AAEI,EAAA,MAAM,cAAqD,EAAC,CAAA;AAE5D,EAAW,KAAA,MAAA,CAAA,IAAK,MAAM,iBACtB,EAAA;AACI,IAAI,IAAA,CAAC,YAAY,CAAC,CAAA;AAAG,MAAA,SAAA;AAErB,IAAM,MAAA,OAAA,GAAU,KAAM,CAAA,iBAAA,CAAkB,CAAC,CAAA,CAAA;AAEzC,IAAA,IAAI,MAAS,GAAA,KAAA,CAAA;AAEb,IAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,cAAA,CAAe,QAAQ,CAC3C,EAAA,EAAA;AACI,MAAM,MAAA,MAAA,GAAS,eAAe,CAAC,CAAA,CAAA;AAE/B,MAAA,IAAI,QAAQ,IAAS,KAAA,MAAA,CAAO,QAAQ,MAAO,CAAA,IAAA,CAAK,OAAO,CACvD,EAAA;AACI,QAAY,WAAA,CAAA,CAAC,CAAI,GAAA,sBAAA,CAAuB,CAAC,CAAA,CAAA;AAEzC,QAAS,MAAA,GAAA,IAAA,CAAA;AAET,QAAA,MAAA;AAAA,OACJ;AAAA,KACJ;AAIA,IAAA,IAAI,CAAC,MACL,EAAA;AACI,MAAA,MAAM,YAAe,GAAA,OAAA,CAAQ,IAAS,KAAA,CAAA,GAAI,4BAA+B,GAAA,2BAAA,CAAA;AAEzE,MAAA,WAAA,CAAY,CAAC,CAAA,GAAI,YAAa,CAAA,OAAA,CAAQ,IAAI,CAAA,CAAA;AAAA,KAC9C;AAAA,GACJ;AAEA,EAAO,OAAA,CACH,EACA,EAAA,EAAA,EACA,QACJ,KAAA;AACI,IAAA,MAAM,KAAK,QAAS,CAAA,EAAA,CAAA;AAEpB,IAAA,KAAA,MAAW,KAAK,WAChB,EAAA;AACI,MAAM,MAAA,CAAA,GAAI,GAAG,CAAC,CAAA,CAAA;AACd,MAAM,MAAA,EAAA,GAAK,GAAG,CAAC,CAAA,CAAA;AACf,MAAM,MAAA,EAAA,GAAK,EAAG,CAAA,CAAC,CAAE,CAAA,KAAA,CAAA;AAEjB,MAAY,WAAA,CAAA,CAAC,EAAE,CAAG,EAAA,EAAA,EAAI,IAAI,CAAG,EAAA,EAAA,EAAI,IAAI,EAAE,CAAA,CAAA;AAAA,KAC3C;AAAA,GACJ,CAAA;AACJ;;;;"}