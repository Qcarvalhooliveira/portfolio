{"version":3,"file":"extractStructAndGroups.mjs","sources":["../../../../../../src/rendering/renderers/gpu/shader/utils/extractStructAndGroups.ts"],"sourcesContent":["export interface StructsAndGroups\n{\n    groups: {\n        group: number;\n        binding: number;\n        name: string;\n        isUniform: boolean;\n        type: string;\n    }[];\n    structs: {\n        name: string;\n        members: Record<string, string>;\n    }[];\n}\n\nexport function extractStructAndGroups(wgsl: string): StructsAndGroups\n{\n    // Patterns for parsing the WGSL file\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n\n    // Find the @group and @binding annotations\n    const groups = wgsl.match(linePattern)?.map((item) => ({\n        group: parseInt(item.match(groupPattern)[1], 10),\n        binding: parseInt(item.match(bindingPattern)[1], 10),\n        name: item.match(namePattern)[2],\n        isUniform: item.match(namePattern)[1] === '<uniform>',\n        type: item.match(typePattern)[1],\n    }));\n\n    if (!groups)\n    {\n        return {\n            groups: [],\n            structs: [],\n        };\n    }\n\n    // Find the structs\n    const structs = wgsl\n        .match(structPattern)\n        ?.map((struct) =>\n        {\n            const name = struct.match(structName)[1];\n            const members = struct.match(structMemberPattern).reduce((acc: Record<string, string>, member) =>\n            {\n                const [name, type] = member.split(':');\n\n                acc[name.trim()] = type.trim();\n\n                return acc;\n            }, {});\n\n            if (!members)\n            {\n                return null;\n            }\n\n            return { name, members };\n            // Only include the structs mentioned in the @group/@binding annotations\n        })\n        .filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n\n    return {\n        groups,\n        structs,\n    };\n}\n"],"names":["name"],"mappings":";AAeO,SAAS,uBAAuB,IACvC,EAAA;AAEI,EAAA,MAAM,WAAc,GAAA,wCAAA,CAAA;AACpB,EAAA,MAAM,YAAe,GAAA,iBAAA,CAAA;AACrB,EAAA,MAAM,cAAiB,GAAA,mBAAA,CAAA;AACvB,EAAA,MAAM,WAAc,GAAA,qBAAA,CAAA;AACpB,EAAA,MAAM,WAAc,GAAA,WAAA,CAAA;AACpB,EAAA,MAAM,aAAgB,GAAA,6BAAA,CAAA;AACtB,EAAA,MAAM,mBAAsB,GAAA,0BAAA,CAAA;AAC5B,EAAA,MAAM,UAAa,GAAA,gBAAA,CAAA;AAGnB,EAAA,MAAM,SAAS,IAAK,CAAA,KAAA,CAAM,WAAW,CAAG,EAAA,GAAA,CAAI,CAAC,IAAU,MAAA;AAAA,IACnD,KAAA,EAAO,SAAS,IAAK,CAAA,KAAA,CAAM,YAAY,CAAE,CAAA,CAAC,GAAG,EAAE,CAAA;AAAA,IAC/C,OAAA,EAAS,SAAS,IAAK,CAAA,KAAA,CAAM,cAAc,CAAE,CAAA,CAAC,GAAG,EAAE,CAAA;AAAA,IACnD,IAAM,EAAA,IAAA,CAAK,KAAM,CAAA,WAAW,EAAE,CAAC,CAAA;AAAA,IAC/B,WAAW,IAAK,CAAA,KAAA,CAAM,WAAW,CAAA,CAAE,CAAC,CAAM,KAAA,WAAA;AAAA,IAC1C,IAAM,EAAA,IAAA,CAAK,KAAM,CAAA,WAAW,EAAE,CAAC,CAAA;AAAA,GACjC,CAAA,CAAA,CAAA;AAEF,EAAA,IAAI,CAAC,MACL,EAAA;AACI,IAAO,OAAA;AAAA,MACH,QAAQ,EAAC;AAAA,MACT,SAAS,EAAC;AAAA,KACd,CAAA;AAAA,GACJ;AAGA,EAAA,MAAM,UAAU,IACX,CAAA,KAAA,CAAM,aAAa,CAClB,EAAA,GAAA,CAAI,CAAC,MACP,KAAA;AACI,IAAA,MAAM,IAAO,GAAA,MAAA,CAAO,KAAM,CAAA,UAAU,EAAE,CAAC,CAAA,CAAA;AACvC,IAAM,MAAA,OAAA,GAAU,OAAO,KAAM,CAAA,mBAAmB,EAAE,MAAO,CAAA,CAAC,KAA6B,MACvF,KAAA;AACI,MAAA,MAAM,CAACA,KAAM,EAAA,IAAI,CAAI,GAAA,MAAA,CAAO,MAAM,GAAG,CAAA,CAAA;AAErC,MAAA,GAAA,CAAIA,KAAK,CAAA,IAAA,EAAM,CAAA,GAAI,KAAK,IAAK,EAAA,CAAA;AAE7B,MAAO,OAAA,GAAA,CAAA;AAAA,KACX,EAAG,EAAE,CAAA,CAAA;AAEL,IAAA,IAAI,CAAC,OACL,EAAA;AACI,MAAO,OAAA,IAAA,CAAA;AAAA,KACX;AAEA,IAAO,OAAA,EAAE,MAAM,OAAQ,EAAA,CAAA;AAAA,GAE1B,CACA,CAAA,MAAA,CAAO,CAAC,EAAE,MAAW,KAAA,MAAA,CAAO,IAAK,CAAA,CAAC,UAAU,KAAM,CAAA,IAAA,KAAS,IAAI,CAAC,KAAK,EAAC,CAAA;AAE3E,EAAO,OAAA;AAAA,IACH,MAAA;AAAA,IACA,OAAA;AAAA,GACJ,CAAA;AACJ;;;;"}