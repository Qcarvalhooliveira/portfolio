{"version":3,"file":"path.js","sources":["../../src/utils/path.ts"],"sourcesContent":["import { DOMAdapter } from '../environment/adapter';\n\nfunction assertPath(path: string)\n{\n    if (typeof path !== 'string')\n    {\n        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);\n    }\n}\n\nfunction removeUrlParams(url: string): string\n{\n    const re = url.split('?')[0];\n\n    return re.split('#')[0];\n}\n\nfunction escapeRegExp(string: string)\n{\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction replaceAll(str: string, find: string, replace: string)\n{\n    return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path: string, allowAboveRoot: boolean)\n{\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = -1;\n\n    for (let i = 0; i <= path.length; ++i)\n    {\n        if (i < path.length)\n        {\n            code = path.charCodeAt(i);\n        }\n        else if (code === 47)\n        {\n            break;\n        }\n        else\n        {\n            code = 47;\n        }\n        if (code === 47)\n        {\n            if (lastSlash === i - 1 || dots === 1)\n            {\n                // NOOP\n            }\n            else if (lastSlash !== i - 1 && dots === 2)\n            {\n                if (\n                    res.length < 2\n                    || lastSegmentLength !== 2\n                    || res.charCodeAt(res.length - 1) !== 46\n                    || res.charCodeAt(res.length - 2) !== 46\n                )\n                {\n                    if (res.length > 2)\n                    {\n                        const lastSlashIndex = res.lastIndexOf('/');\n\n                        if (lastSlashIndex !== res.length - 1)\n                        {\n                            if (lastSlashIndex === -1)\n                            {\n                                res = '';\n                                lastSegmentLength = 0;\n                            }\n                            else\n                            {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    }\n                    else if (res.length === 2 || res.length === 1)\n                    {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot)\n                {\n                    if (res.length > 0)\n                    { res += '/..'; }\n                    else\n                    { res = '..'; }\n                    lastSegmentLength = 2;\n                }\n            }\n            else\n            {\n                if (res.length > 0)\n                {\n                    res += `/${path.slice(lastSlash + 1, i)}`;\n                }\n                else\n                {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === 46 && dots !== -1)\n        {\n            ++dots;\n        }\n        else\n        {\n            dots = -1;\n        }\n    }\n\n    return res;\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * ```js\n * import { path } from 'pixi.js';\n *\n * path.normalize('http://www.example.com/foo/bar/../baz'); // http://www.example.com/foo/baz\n * ```\n * @memberof utils\n */\nexport interface Path\n{\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix: (path: string) => string;\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     */\n    isUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     */\n    isBlobUrl: (path: string) => boolean;\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol: (path: string) => boolean;\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     */\n    getProtocol: (path: string) => string;\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     */\n    toAbsolute: (url: string, baseUrl?: string, rootUrl?: string) => string;\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize: (path: string) => string;\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute: (path: string) => boolean;\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     */\n    join: (...paths: string[]) => string;\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname: (path: string) => string;\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname: (path: string) => string;\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename: (path: string, ext?: string) => string;\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname: (path: string) => string;\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse: (path: string) => { root?: string, dir?: string, base?: string, ext?: string, name?: string };\n    sep: string,\n    delimiter: string,\n    joinExtensions: string[],\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * ```js\n * import { path } from 'pixi.js';\n *\n * path.normalize('http://www.example.com/foo/bar/../baz'); // http://www.example.com/foo/baz\n * ```\n * @see {@link utils.Path}\n * @memberof utils\n */\nexport const path: Path = {\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix(path: string) { return replaceAll(path, '\\\\', '/'); },\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     */\n    isUrl(path: string) { return (/^https?:/).test(this.toPosix(path)); },\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl(path: string)\n    {\n        // eslint-disable-next-line max-len\n        return (/^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i)\n            .test(path);\n    },\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     */\n    isBlobUrl(path: string)\n    {\n        // Not necessary to have an exact regex to match the blob URLs\n        return path.startsWith('blob:');\n    },\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol(path: string) { return (/^[^/:]+:/).test(this.toPosix(path)); },\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     */\n    getProtocol(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        const matchFile = (/^file:\\/\\/\\//).exec(path);\n\n        if (matchFile)\n        {\n            return matchFile[0];\n        }\n\n        const matchProtocol = (/^[^/:]+:\\/{0,2}/).exec(path);\n\n        if (matchProtocol)\n        {\n            return matchProtocol[0];\n        }\n\n        return '';\n    },\n\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     */\n    toAbsolute(url: string, customBaseUrl?: string, customRootUrl?: string)\n    {\n        assertPath(url);\n\n        if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;\n\n        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));\n        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n\n        url = this.toPosix(url);\n\n        // root relative url\n        if (url.startsWith('/'))\n        {\n            return path.join(rootUrl, url.slice(1));\n        }\n\n        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n\n        return absolutePath;\n    },\n\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize(path: string)\n    {\n        assertPath(path);\n\n        if (path.length === 0) return '.';\n        if (this.isDataUrl(path) || this.isBlobUrl(path)) return path;\n\n        path = this.toPosix(path);\n\n        let protocol = '';\n        const isAbsolute = path.startsWith('/');\n\n        if (this.hasProtocol(path))\n        {\n            protocol = this.rootname(path);\n            path = path.slice(protocol.length);\n        }\n\n        const trailingSeparator = path.endsWith('/');\n\n        // Normalize the path\n        path = normalizeStringPosix(path, false);\n\n        if (path.length > 0 && trailingSeparator) path += '/';\n        if (isAbsolute) return `/${path}`;\n\n        return protocol + path;\n    },\n\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        if (this.hasProtocol(path)) return true;\n\n        return path.startsWith('/');\n    },\n\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     */\n    join(...segments: string[])\n    {\n        if (segments.length === 0)\n        { return '.'; }\n        let joined;\n\n        for (let i = 0; i < segments.length; ++i)\n        {\n            const arg = segments[i];\n\n            assertPath(arg);\n            if (arg.length > 0)\n            {\n                if (joined === undefined) joined = arg;\n                else\n                {\n                    const prevArg = segments[i - 1] ?? '';\n\n                    if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase()))\n                    {\n                        joined += `/../${arg}`;\n                    }\n                    else\n                    {\n                        joined += `/${arg}`;\n                    }\n                }\n            }\n        }\n        if (joined === undefined) { return '.'; }\n\n        return this.normalize(joined);\n    },\n\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname(path: string)\n    {\n        assertPath(path);\n        if (path.length === 0) return '.';\n        path = this.toPosix(path);\n        let code = path.charCodeAt(0);\n        const hasRoot = code === 47;\n        let end = -1;\n        let matchedSlash = true;\n\n        const proto = this.getProtocol(path);\n        const origpath = path;\n\n        path = path.slice(proto.length);\n\n        for (let i = path.length - 1; i >= 1; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                if (!matchedSlash)\n                {\n                    end = i;\n                    break;\n                }\n            }\n            else\n            {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n\n        // if end is -1 and its a url then we need to add the path back\n        // eslint-disable-next-line no-nested-ternary\n        if (end === -1) return hasRoot ? '/' : this.isUrl(origpath) ? proto + path : proto;\n        if (hasRoot && end === 1) return '//';\n\n        return proto + path.slice(0, end);\n    },\n\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        let root = '';\n\n        if (path.startsWith('/')) root = '/';\n        else\n        {\n            root = this.getProtocol(path);\n        }\n\n        if (this.isUrl(path))\n        {\n            // need to find the first path separator\n            const index = path.indexOf('/', root.length);\n\n            if (index !== -1)\n            {\n                root = path.slice(0, index);\n            }\n            else root = path;\n\n            if (!root.endsWith('/')) root += '/';\n        }\n\n        return root;\n    },\n\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename(path: string, ext?: string)\n    {\n        assertPath(path);\n        if (ext) assertPath(ext);\n\n        path = removeUrlParams(this.toPosix(path));\n\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i: number;\n\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length)\n        {\n            if (ext.length === path.length && ext === path) return '';\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n\n            for (i = path.length - 1; i >= 0; --i)\n            {\n                const code = path.charCodeAt(i);\n\n                if (code === 47)\n                {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash)\n                    {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else\n                {\n                    if (firstNonSlashEnd === -1)\n                    {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0)\n                    {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx))\n                        {\n                            if (--extIdx === -1)\n                            {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else\n                        {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n\n            if (start === end) end = firstNonSlashEnd; else if (end === -1) end = path.length;\n\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i)\n        {\n            if (path.charCodeAt(i) === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n\n        if (end === -1) return '';\n\n        return path.slice(start, end);\n    },\n\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname(path: string)\n    {\n        assertPath(path);\n        path = removeUrlParams(this.toPosix(path));\n\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        for (let i = path.length - 1; i >= 0; --i)\n        {\n            const code = path.charCodeAt(i);\n\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators, no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            return '';\n        }\n\n        return path.slice(startDot, end);\n    },\n\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse(path: string)\n    {\n        assertPath(path);\n\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\n        if (path.length === 0) return ret;\n        path = removeUrlParams(this.toPosix(path));\n\n        let code = path.charCodeAt(0);\n        const isAbsolute = this.isAbsolute(path);\n        let start: number;\n        const protocol = '';\n\n        ret.root = this.rootname(path);\n\n        if (isAbsolute || this.hasProtocol(path))\n        {\n            start = 1;\n        }\n        else\n        {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        // Get non-dir info\n        for (; i >= start; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators, no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            if (end !== -1)\n            {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);\n                else ret.base = ret.name = path.slice(startPart, end);\n            }\n        }\n        else\n        {\n            if (startPart === 0 && isAbsolute)\n            {\n                ret.name = path.slice(1, startDot);\n                ret.base = path.slice(1, end);\n            }\n            else\n            {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n            }\n            ret.ext = path.slice(startDot, end);\n        }\n\n        ret.dir = this.dirname(path);\n        if (protocol) ret.dir = protocol + ret.dir;\n\n        return ret;\n    },\n\n    sep: '/',\n    delimiter: ':',\n    joinExtensions: ['.html'],\n} as Path;\n"],"names":["path","DOMAdapter"],"mappings":"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"}